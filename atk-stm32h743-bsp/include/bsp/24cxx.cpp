#include "24cxx.h"
#include <bsp-interface/di/delayer.h>
#include <bsp-interface/di/gpio.h>
#include <bsp-interface/di/iic.h>
#include <bsp-interface/serial/GpioSoftwareIicHost.h>
#include <hal.h>

bsp::IIicHost *_iic_host = nullptr;

// 初始化IIC接口
void AT24CXX_Init()
{
    _iic_host = DI_IicHostCollection().Get("eerom_iic_host");
    _iic_host->Open();
}

// 在AT24CXX指定地址读出一个数据
// ReadAddr:开始读数的地址
// 返回值  :读到的数据
uint8_t AT24CXX_ReadOneByte(uint16_t ReadAddr)
{
    uint8_t temp = 0;
    _iic_host->SendStartingSignal();
    if (EE_TYPE > AT24C16)
    {
        _iic_host->SendByte(0XA0);          // 发送写命令
        _iic_host->SendByte(ReadAddr >> 8); // 发送高地址
    }
    else
    {
        _iic_host->SendByte(0XA0 + ((ReadAddr / 256) << 1)); // 发送器件地址0XA0,写数据
    }

    _iic_host->SendByte(ReadAddr % 256); // 发送低地址
    _iic_host->SendStartingSignal();
    _iic_host->SendByte(0XA1); // 进入接收模式
    temp = _iic_host->ReceiveByte(1);
    _iic_host->SendStoppingSignal(); // 产生一个停止条件
    return temp;
}

// 在AT24CXX指定地址写入一个数据
// WriteAddr  :写入数据的目的地址
// DataToWrite:要写入的数据
void AT24CXX_WriteOneByte(uint16_t WriteAddr, uint8_t DataToWrite)
{
    _iic_host->SendStartingSignal();
    if (EE_TYPE > AT24C16)
    {
        _iic_host->SendByte(0XA0);           // 发送写命令
        _iic_host->SendByte(WriteAddr >> 8); // 发送高地址
    }
    else
    {
        _iic_host->SendByte(0XA0 + ((WriteAddr / 256) << 1)); // 发送器件地址0XA0,写数据
    }

    _iic_host->SendByte(WriteAddr % 256); // 发送低地址
    _iic_host->SendByte(DataToWrite);     // 发送字节
    _iic_host->SendStoppingSignal();      // 产生一个停止条件
    DI_Delayer().Delay(std::chrono::milliseconds{10});
}

// 在AT24CXX里面的指定地址开始写入长度为Len的数据
// 该函数用于写入16bit或者32bit的数据.
// WriteAddr  :开始写入的地址
// DataToWrite:数据数组首地址
// Len        :要写入数据的长度2,4
void AT24CXX_WriteLenByte(uint16_t WriteAddr, uint32_t DataToWrite, uint8_t Len)
{
    uint8_t t;
    for (t = 0; t < Len; t++)
    {
        AT24CXX_WriteOneByte(WriteAddr + t, (DataToWrite >> (8 * t)) & 0xff);
    }
}

// 在AT24CXX里面的指定地址开始读出长度为Len的数据
// 该函数用于读出16bit或者32bit的数据.
// ReadAddr   :开始读出的地址
// 返回值     :数据
// Len        :要读出数据的长度2,4
uint32_t AT24CXX_ReadLenByte(uint16_t ReadAddr, uint8_t Len)
{
    uint8_t t;
    uint32_t temp = 0;
    for (t = 0; t < Len; t++)
    {
        temp <<= 8;
        temp += AT24CXX_ReadOneByte(ReadAddr + Len - t - 1);
    }

    return temp;
}

// 检查AT24CXX是否正常
// 这里用了24XX的最后一个地址(255)来存储标志字.
// 如果用其他24C系列,这个地址要修改
// 返回1:检测失败
// 返回0:检测成功
uint8_t AT24CXX_Check()
{
    uint8_t temp;
    temp = AT24CXX_ReadOneByte(255); // 避免每次开机都写AT24CXX
    if (temp == 0X55)
    {
        return 0;
    }
    else // 排除第一次初始化的情况
    {
        AT24CXX_WriteOneByte(255, 0X55);
        temp = AT24CXX_ReadOneByte(255);
        if (temp == 0X55)
        {
            return 0;
        }
    }

    return 1;
}

// 在AT24CXX里面的指定地址开始读出指定个数的数据
// ReadAddr :开始读出的地址 对24c02为0~255
// pBuffer  :数据数组首地址
// NumToRead:要读出数据的个数
void AT24CXX_Read(uint16_t ReadAddr, uint8_t *pBuffer, uint16_t NumToRead)
{
    while (NumToRead)
    {
        *pBuffer++ = AT24CXX_ReadOneByte(ReadAddr++);
        NumToRead--;
    }
}

// 在AT24CXX里面的指定地址开始写入指定个数的数据
// WriteAddr :开始写入的地址 对24c02为0~255
// pBuffer   :数据数组首地址
// NumToWrite:要写入数据的个数
void AT24CXX_Write(uint16_t WriteAddr, uint8_t *pBuffer, uint16_t NumToWrite)
{
    while (NumToWrite--)
    {
        AT24CXX_WriteOneByte(WriteAddr, *pBuffer);
        WriteAddr++;
        pBuffer++;
    }
}
